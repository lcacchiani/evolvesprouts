# Cursor rules for Evolve Sprouts repository
# Sources:
# - Internal repo architecture/docs
# - Flutter, Python, React/TypeScript, and Next.js guidance

## Scope and applicability (MANDATORY)

- These rules apply to ALL executions in this repository, including:
  analysis, planning, implementation, refactors, tests, docs, and git ops.
- Use path-aware rules:
  - If a change touches `backend/**`, backend + security + docs rules apply.
  - If a change touches `apps/evolvesprouts_app/**`, Flutter rules apply.
  - If a change touches `apps/crm_web/**` or `apps/public_www/**`,
    web rules apply.
  - If a change touches multiple areas, satisfy all relevant sections.
- If two rules conflict, follow the more specific rule for the changed path.

## Repository structure (current)

repo root
|-- apps/
|   |-- evolvesprouts_app/    # Flutter mobile app
|   |-- crm_web/              # Next.js admin shell
|   `-- public_www/           # Next.js public website
|-- backend/
|   |-- db/                   # Alembic + seed SQL
|   |-- infrastructure/       # AWS CDK stacks (TypeScript)
|   |-- lambda/               # Lambda handlers
|   |-- src/app/              # Shared Python app code
|   `-- requirements.txt
|-- docs/
|   |-- api/                  # OpenAPI specs
|   `-- architecture/         # Architecture docs
|-- scripts/
`-- tests/

## Constraints (MANDATORY)

- Never proceed with new files if similar functionality already exists.
- If the approved plan changes, re-submit the updated plan for approval.
- Use simple future tense in plans:
  - Good: "I will modify..."
  - Avoid: "I am modifying..."
- S3 bucket names must be 63 characters or less.
- Never hardcode secrets, API keys, passwords, or tokens.

## Workflow (MANDATORY)

1. Analyze the user request and relevant repository context.
2. Plan in chat before editing code. The plan must include:
   - files to modify/create
   - functions/components/modules to change
   - edge cases and risks
   - questions to validate assumptions
3. Wait for explicit user approval.
4. Execute only after approval.
   - Treat all write operations as implementation and blocked before approval.
   - Implementation includes file create/edit/delete, dependency changes,
     migrations, generated artifacts, and git write operations
     (`git add`, `git commit`, `git push`).
   - Read-only analysis steps (search, file reads, planning) are allowed before
     approval.
5. If implementation scope changes after approval, stop and request renewed
   explicit user approval.
6. Validate with focused checks/tests for touched areas.
7. For any Python change, run:
   `pre-commit run ruff-format --all-files`
   before committing.
8. Keep the repository AI-rule contract validation passing:
   `bash scripts/validate-cursorrules.sh`

## Architecture decisions (repository baseline)

- Admin web app uses Next.js App Router under `apps/crm_web/src/app`.
- Public website uses Next.js static export in `apps/public_www`.
- Infrastructure as Code uses AWS CDK (TypeScript) in
  `backend/infrastructure`.
- Lambda handlers are under `backend/lambda/**` and shared backend code is
  under `backend/src/app/**`.
- Aurora PostgreSQL schema is managed by Alembic in `backend/db`.
- In-VPC Lambda database access is through RDS Proxy with IAM auth.
- In-VPC Lambda calls to Cognito/external HTTP must go through
  `app.services.aws_proxy.invoke()` or `http_invoke()`.
- API endpoint contracts are documented only in `docs/api/*.yaml`.

## Backend and API rules (MANDATORY for backend changes)

- Register new API routes in:
  `backend/infrastructure/lib/api-stack.ts`
- Keep API Gateway route paths exactly aligned with Lambda handlers.
- For every new or changed endpoint:
  1. Update API Gateway route wiring in CDK.
  2. Update OpenAPI in `docs/api/admin.yaml` or `docs/api/search.yaml`.
  3. Update Lambda catalog in `docs/architecture/lambdas.md`.
- Do not merge endpoint work without all three updates.
- Do not call boto3 `cognito-idp` directly from in-VPC Lambdas.
  Use the AWS proxy service helpers instead.

## Database change rules (MANDATORY for schema changes)

- Alembic revision IDs must be <= 32 characters.
  - Format: `NNNN_short_description`
  - Example: `0010_add_audit_logging`
  - Validate length with:
    `echo -n "revision_id" | wc -c`
- Seed-data assessment is required for EVERY DB change.
  Seed file: `backend/db/seed/seed_data.sql`
- Checklist (must answer all):
  1. Compatibility with existing seed SQL.
  2. New NOT NULL/CHECK-constrained columns handled in seed data.
  3. Renamed/dropped columns reflected in seed data.
  4. New tables evaluated for seed rows.
  5. Enum/allowed-value changes validated in seed rows.
  6. FK/cascade changes validated for insert order and references.
- Confirm migration + seed sequence mentally or in practice:
  `alembic upgrade head` then `psql -f seed_data.sql`
- If no seed update is needed, add a brief commit/PR note explaining why.

## Documentation freshness (MANDATORY after code changes)

- Keep relevant docs updated with code changes:
  - `docs/api/*.yaml` for endpoint/schema/auth changes
  - `docs/architecture/lambdas.md` for Lambda inventory/behavior changes
  - `docs/architecture/database-schema.md` for table/column changes
  - `docs/architecture/aws-assets-map.md` for AWS/IAM/CDK output changes
  - `docs/architecture/overview.md` for high-level architecture changes
  - `docs/architecture/decisions.md` for architectural pattern changes
  - `docs/architecture/security.md` for security model changes
  - `docs/architecture/aws-messaging.md` for SNS/SQS pattern changes
  - `docs/architecture/audit-logging.md` for audit behavior changes
  - `.cursorrules` when project conventions change
- Architecture docs describe design and decisions.
  Endpoint specifics belong only in OpenAPI specs.

## Web testing requirements (MANDATORY for web behavior changes)

- Applies to `apps/crm_web` and `apps/public_www`.
- When UI/API changes alter web behavior, update existing tests and fixtures
  in the app's current testing framework.
- If coverage is missing, add focused tests in the app's existing toolchain.
- Do not require Playwright unless it is already in use for the touched app
  or explicitly requested.
- Keep mock responses aligned with `docs/api/*.yaml` and current UI behavior.

## Security requirements (MANDATORY)

- Never log unmasked PII.
  Use `mask_email()` and `mask_pii()` from `app.utils.logging`.
- Never use `print()` in production code.
  Use structured logging with `get_logger()`.
- Never use `random` for security tokens; use `secrets`.
- Never use `Cors.ALL_ORIGINS` in production.
- Always use `noEcho: true` for secret CDK parameters.
- Always use fail-closed attestation in production
  (`ATTESTATION_FAIL_CLOSED=true`).
- Always validate and sanitize user input.
- Always enforce SSL for DB connections (`sslmode=require`).

## General code style

- Write concise, readable, and maintainable code.
- Avoid duplication; prefer reusable components/functions.
- Use descriptive names (for example, `isLoading`, `hasError`).
- Keep Python files under 500 lines.

## Flutter rules (apply to `apps/evolvesprouts_app/**`)

- Use MVVM-style separation where practical:
  - `lib/models/`
  - `lib/viewmodels/`
  - `lib/views/widgets/`
  - `lib/views/screens/`
  - `lib/services/`
  - `lib/utils/`
- Prefer `StatelessWidget` when state is not needed.
- Use `const` constructors for immutable widgets.
- Use Riverpod for state management patterns in this app.
- Use Material widgets and consistent `ThemeData`.
- Naming:
  - files/directories: snake_case
  - classes/types: UpperCamelCase
  - variables/methods: lowerCamelCase
- Import order:
  1. `dart:*`
  2. third-party `package:*`
  3. project-relative imports

## Next.js and TypeScript rules

### Applies to `apps/crm_web/**` and `apps/public_www/**`

- Use TypeScript for app code.
- Prefer functional components and declarative composition.
- Prefer server components by default; minimize `use client`.
- Use `src/app` for routes and `src/components` for shared components.
- Favor named exports for reusable components.
- Use descriptive, intention-revealing names.
- Keep Tailwind usage consistent and mobile-first.
- For simple pure helpers, use the `function` keyword.
- Styling must live in CSS classes/files, not inline style objects.
- Never use `style={...}` or `style=""` in JSX (MANDATORY).
- Never use `CSSProperties` / `React.CSSProperties` in app code (MANDATORY).

### Public WWW XSS policy (MANDATORY for `apps/public_www/**`)

- Do not use `dangerouslySetInnerHTML`.
- Do not use `eval()` or `new Function()`.
- Keep `csp:inject` and `csp:validate` required in the public website build
  pipeline.
- During code review, reject changes introducing any of these patterns.

### Public WWW component and test structure (MANDATORY for `apps/public_www/**`)

- Place page composition components in `apps/public_www/src/components/pages/**`.
- Place reusable UI primitives/layout helpers in
  `apps/public_www/src/components/shared/**`.
- Place section components in `apps/public_www/src/components/sections/**`.
- Place section-only shared helpers in
  `apps/public_www/src/components/sections/shared/**`.
- Place all unit/component tests in `apps/public_www/tests/**`.
- Do not create `*.test.*` or `*.spec.*` files under
  `apps/public_www/src/**`.
- Mirror source domains in tests (`tests/components/**`, `tests/lib/**`,
  `tests/content/**`) to keep navigation predictable.

## React/Redux guidance (when Redux is used)

- Use Redux Toolkit patterns (`createSlice`, `createAsyncThunk`).
- Use typed hooks for dispatch/selectors.
- Keep selectors in one place and reuse them.
- Add robust async error handling and user-safe error states.

## Python project guidance (apply to `backend/**` and `tests/**`)

- Keep modules focused and composable (models/services/controllers/utils).
- Use type hints and clear function signatures.
- Use robust error handling with contextual logging.
- Use pytest for tests.
- Keep docstrings and README/docs aligned with behavior.
- Use Ruff-based formatting/lint workflows configured by the repo.
