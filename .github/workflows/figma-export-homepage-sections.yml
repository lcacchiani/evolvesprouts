name: Export Figma Homepage Sections

on:
  push:
    branches:
      - cursor/public-website-design-9b60
    paths:
      - '.github/workflows/figma-export-homepage-sections.yml'
  workflow_dispatch:

permissions:
  contents: read

jobs:
  export:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 'lts/*'
          cache: 'npm'
          cache-dependency-path: apps/public_www/package-lock.json

      - name: Install dependencies
        run: npm ci
        working-directory: apps/public_www

      - name: Pull Figma file metadata
        run: npm run figma:pull
        working-directory: apps/public_www
        env:
          FIGMA_OAUTH_ACCESS_TOKEN: ${{ secrets.FIGMA_OAUTH_ACCESS_TOKEN }}
          FIGMA_OAUTH_CLIENT_ID: ${{ secrets.FIGMA_OAUTH_CLIENT_ID }}
          FIGMA_OAUTH_CLIENT_SECRET: ${{ secrets.FIGMA_OAUTH_CLIENT_SECRET }}
          FIGMA_OAUTH_REFRESH_TOKEN: ${{ secrets.FIGMA_OAUTH_REFRESH_TOKEN }}
          FIGMA_OAUTH_TOKEN_URL: ${{ vars.PUBLIC_WWW_FIGMA_OAUTH_TOKEN_URL }}
          FIGMA_FILE_KEY: ${{ vars.PUBLIC_WWW_FIGMA_FILE_KEY }}

      - name: Export section images
        working-directory: apps/public_www
        env:
          FIGMA_OAUTH_ACCESS_TOKEN: ${{ secrets.FIGMA_OAUTH_ACCESS_TOKEN }}
          FIGMA_OAUTH_CLIENT_ID: ${{ secrets.FIGMA_OAUTH_CLIENT_ID }}
          FIGMA_OAUTH_CLIENT_SECRET: ${{ secrets.FIGMA_OAUTH_CLIENT_SECRET }}
          FIGMA_OAUTH_REFRESH_TOKEN: ${{ secrets.FIGMA_OAUTH_REFRESH_TOKEN }}
          FIGMA_OAUTH_TOKEN_URL: ${{ vars.PUBLIC_WWW_FIGMA_OAUTH_TOKEN_URL }}
          FIGMA_FILE_KEY: ${{ vars.PUBLIC_WWW_FIGMA_FILE_KEY }}
        run: |
          node <<'NODE'
          import { mkdir, readFile, writeFile } from 'node:fs/promises';
          import path from 'node:path';

          function getEnv(name) {
            return process.env[name]?.trim() ?? '';
          }

          function slugify(input) {
            return input
              .toLowerCase()
              .trim()
              .replaceAll(/[^a-z0-9]+/g, '-')
              .replaceAll(/^-+|-+$/g, '');
          }

          async function resolveAccessToken() {
            const directToken = getEnv('FIGMA_OAUTH_ACCESS_TOKEN');
            if (directToken) {
              return directToken;
            }

            const clientId = getEnv('FIGMA_OAUTH_CLIENT_ID');
            const clientSecret = getEnv('FIGMA_OAUTH_CLIENT_SECRET');
            const refreshToken = getEnv('FIGMA_OAUTH_REFRESH_TOKEN');
            const tokenUrl =
              getEnv('FIGMA_OAUTH_TOKEN_URL') ||
              'https://api.figma.com/v1/oauth/token';

            if (!clientId || !clientSecret || !refreshToken) {
              throw new Error(
                'Missing OAuth env vars for access token resolution.',
              );
            }

            const body = new URLSearchParams({
              grant_type: 'refresh_token',
              client_id: clientId,
              client_secret: clientSecret,
              refresh_token: refreshToken,
            });
            const response = await fetch(tokenUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
              },
              body,
            });
            if (!response.ok) {
              const text = await response.text();
              throw new Error(
                `Token exchange failed (${response.status}): ${text.slice(0, 500)}`,
              );
            }

            const payload = await response.json();
            const accessToken = payload.access_token?.trim?.() ?? '';
            if (!accessToken) {
              throw new Error('Token exchange succeeded but no access_token.');
            }
            return accessToken;
          }

          async function getJson(url, accessToken) {
            const response = await fetch(url, {
              headers: {
                Authorization: `Bearer ${accessToken}`,
              },
            });
            if (!response.ok) {
              const text = await response.text();
              throw new Error(
                `Figma request failed (${response.status}) for ${url}: ${text.slice(0, 500)}`,
              );
            }
            return response.json();
          }

          function wait(ms) {
            return new Promise((resolve) => {
              setTimeout(resolve, ms);
            });
          }

          async function getImageUrlForNode(fileKey, nodeId, accessToken) {
            const endpoint = `https://api.figma.com/v1/images/${fileKey}?ids=${encodeURIComponent(nodeId)}&format=png&scale=2`;
            const retryMs = [500, 1000, 2000, 4000];
            let lastError = null;
            for (const [index, delay] of retryMs.entries()) {
              try {
                const payload = await getJson(endpoint, accessToken);
                return payload.images?.[nodeId] ?? '';
              } catch (error) {
                lastError = error;
                const message = String(error?.message ?? '');
                const isRetryable =
                  message.includes('Figma request failed (500)') ||
                  message.includes('Figma request failed (429)');
                const isLastAttempt = index === retryMs.length - 1;
                if (!isRetryable || isLastAttempt) {
                  break;
                }
                await wait(delay);
              }
            }
            throw lastError;
          }

          function findByName(root, name) {
            const queue = [root];
            while (queue.length > 0) {
              const node = queue.shift();
              if (node?.name === name) {
                return node;
              }
              const children = Array.isArray(node?.children) ? node.children : [];
              queue.push(...children);
            }
            return null;
          }

          async function main() {
            const figmaFileKey = getEnv('FIGMA_FILE_KEY');
            if (!figmaFileKey) {
              throw new Error('FIGMA_FILE_KEY is required.');
            }

            const outputRoot = path.join('figma', 'files', 'homepage-sections');
            const imagesDir = path.join(outputRoot, 'images');
            await mkdir(imagesDir, { recursive: true });

            const localFilePath = path.join('figma', 'files', 'file.json');
            const localFileJson = JSON.parse(await readFile(localFilePath, 'utf8'));
            const document = localFileJson.document;
            const desktopNode = findByName(document, 'Desktop');
            const mobileNode = findByName(document, 'Mobile');

            if (!desktopNode) {
              throw new Error('Could not find Desktop node in file.json.');
            }

            const desktopSections = (desktopNode.children ?? [])
              .map((node) => {
                const bounds = node.absoluteBoundingBox ?? {};
                return {
                  id: node.id,
                  name: node.name,
                  type: node.type,
                  x: bounds.x ?? 0,
                  y: bounds.y ?? 0,
                  width: bounds.width ?? 0,
                  height: bounds.height ?? 0,
                };
              })
              .sort((a, b) => a.y - b.y);

            const summary = {
              fileName: localFileJson.name,
              fileKey: figmaFileKey,
              desktop: {
                id: desktopNode.id,
                name: desktopNode.name,
                width: desktopNode.absoluteBoundingBox?.width ?? 0,
                height: desktopNode.absoluteBoundingBox?.height ?? 0,
                sections: desktopSections,
              },
              mobile: mobileNode
                ? {
                    id: mobileNode.id,
                    name: mobileNode.name,
                    width: mobileNode.absoluteBoundingBox?.width ?? 0,
                    height: mobileNode.absoluteBoundingBox?.height ?? 0,
                  }
                : null,
            };

            await writeFile(
              path.join(outputRoot, 'summary.json'),
              `${JSON.stringify(summary, null, 2)}\n`,
              'utf8',
            );

            const accessToken = await resolveAccessToken();

            const manifest = [];
            for (const section of desktopSections) {
              const imageUrl = await getImageUrlForNode(
                figmaFileKey,
                section.id,
                accessToken,
              );
              if (!imageUrl) {
                continue;
              }
              const imageResponse = await fetch(imageUrl);
              if (!imageResponse.ok) {
                const body = await imageResponse.text();
                throw new Error(
                  `Failed downloading section ${section.id} image (${imageResponse.status}): ${body.slice(0, 500)}`,
                );
              }
              const safeName = slugify(section.name);
              const fileName = `${safeName || 'section'}-${section.id.replaceAll(':', '-')}.png`;
              const outputPath = path.join(imagesDir, fileName);
              const bytes = Buffer.from(await imageResponse.arrayBuffer());
              await writeFile(outputPath, bytes);
              manifest.push({
                ...section,
                fileName,
                path: `images/${fileName}`,
              });
            }

            if (mobileNode?.id) {
              const mobileImageUrl = await getImageUrlForNode(
                figmaFileKey,
                mobileNode.id,
                accessToken,
              );
              if (mobileImageUrl) {
                const imageResponse = await fetch(mobileImageUrl);
                if (!imageResponse.ok) {
                  const body = await imageResponse.text();
                  throw new Error(
                    `Failed downloading mobile image (${imageResponse.status}): ${body.slice(0, 500)}`,
                  );
                }
                const fileName = `mobile-full-${mobileNode.id.replaceAll(':', '-')}.png`;
                const bytes = Buffer.from(await imageResponse.arrayBuffer());
                await writeFile(path.join(imagesDir, fileName), bytes);
              }
            }

            await writeFile(
              path.join(outputRoot, 'manifest.json'),
              `${JSON.stringify(manifest, null, 2)}\n`,
              'utf8',
            );
            console.log(`Exported ${manifest.length} desktop section image(s).`);
          }

          await main();
          NODE

      - name: Upload section artifact
        uses: actions/upload-artifact@v4
        with:
          name: figma-homepage-sections
          path: |
            apps/public_www/figma/files/file.json
            apps/public_www/figma/files/homepage-sections/summary.json
            apps/public_www/figma/files/homepage-sections/manifest.json
            apps/public_www/figma/files/homepage-sections/images/*.png
